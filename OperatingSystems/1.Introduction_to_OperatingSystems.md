# 1. Introduction to Operating Systems

# 0. 정보기술의 원리와 철학

컴퓨터 및 정보기술 분야는 매우 빠른 변화를 겪는 학문이다. 하지만 `컴퓨터 분야의 기본 원리` 및 `정보기술 분야가 추구하는 핵심 철학`은 시대가 흘러도 변하지 않는다.

1937년 수학자 앨런 튜링이 개발한 이론적 컴퓨터인 **튜링머신**이 현대 컴퓨터가 풀 수 있는 모든 문제를 풀 수 있다는 사실이 증명되었다.

컴퓨터 분야의 학문은 컴퓨터 자체를 효율적으로 운영하기 위한 학문, 그리고 복잡한 문제를 컴퓨터를 활용해서 효율적으로 풀 수 있는 방법을 제공하기 위한 학문으로 나뉜다.

하지만 두 분야 모두 사람이 다루는 문제보다 **복잡도(complexity)**가 매우 높은 문제를 다루고 있어 방법론적으로는 크게 다르지 않다.

# 1. Introduction to Operating Systems

운영체제란?
컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어

`협의의 운영체제(커널)`

운영체제의 핵심 부분으로 메모리에 상주하는 부분

`광의의 운영체제`

커널 뿐 아니라 각종 주변 시스템 유틸리티를 포함한 개념

소프트웨어가 컴퓨터 시스템에서 실행되기 위해서는 **메모리**에 그 프로그램이 올라가 있어야 한다. 운영체제 자체도 `소프트웨어`로서 전원이 켜짐과 동시에 메모리에 올라간다. 하지만 운영체제처럼 규모가 큰 프로그램이 모두 메모리에 올라가면 자원의 낭비가 심하므로, 운영체제 중 항상 필요한 부분만을 올려놓고 나머지 부분은 필요할 때 메모리로 올려서 사용한다.

`커널(kernel)` 

이 때 메모리에 상주하는 운영체제의 부분. 커널은 운영체제 코드 중에서도 핵심적인 부분임

`유틸리티(utility)` 

필요할 때 메모리로 올려서 사용하는 별도의 프로그램

e.g. 윈도우 환경에서 파일 복사 프로그램

## 운영체제의 목적

컴퓨터 하드웨어와 사용자 사이에 운영체제가 존재하므로, 운영체제의 역할은 `하드웨어를 위한 역할`과 `사용자를 위한 역할` 두 가지로 나누어 볼 수 있다.

1. 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공(=인터페이스 제공)
    - 운영체제는 동시 사용자/프로그램들이 각각 독자적 컴퓨터에서 수행되는것 같은 환상을 제공
    - 하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행
    - 사용자는 파일이 디스크에 어떻게 저장되는지 자세히 알지 못하지만, 인터페이스를 통해 손쉽게 파일을 저장하거나 파일의 내용을 꺼내볼 수 있다.
2. 컴퓨터 시스템의 자원을 효율적으로 관리
    - 프로세서, 기억장치, 입출력 장치 등의 효율적 관리
    - 사용자 및 운영체제 자신을 보호(보안)
    - 프로세스, 파일, 메시지 등을 관리

## 운영체제의 분류

### 동시작업 가능 여부

`단일작업(single tasking)`

한번의 하나의 작업만 처리

- 초창기 운영체제
- 도스(DOS : Disk Operating System)

`다중작업(multi tasking)`

동시에 두 개 이상의 작업 처리

- 최근의 대부분 운영체제
- 윈도우, 유닉스
- 다중작업, 시분할, 다중 프로그래밍, 대화형 시스템 모두 **여러 프로그램이 하나의 컴퓨터에서 동시에 실행**된다.

### 사용자의 수(동시 사용자)

`단일 사용자`

e.g. MS-DOS, MS Windows

`다중 사용자`

e.g. UNIX, NT server

### 처리 방식

`일괄 처리(batch processing)`

작업 요청을 일정량 모아서 한꺼번에 처리(작업이 완전 종료될때까지 기다려야 함)

현재는 시분할을 주로 사용. 진짜 옛날에만 사용했었음

- 초창기 컴퓨터에 사용되던 펀치 카드(punch card) 처리 시스템

`시분할(time sharing system)`

여러 작업을 수행할 때 처리 능력을 일정한 단위로 분할하여 사용(interactive한 방식)

시간을 준수한다기 보다는 사람에 특화된 시스템

- 현대의 대부분의 범용 컴퓨터

`실시간`

정해진 시간 안에 어떠한 일이 반드시 종료됨을 보장되어야 하는 실시간 시스템을 위한 OS

실시간 시스템의 개념 확장

- Hard realtime system
- Soft realtime system

이 수업에서는 시분할을 주로 다룸. 다만 최근 실시간성을 요구하는 프로그램들이 늘어남.

- 원자로, 공장 제어 시스템, 미사일 제어 시스템

## 용어 정리

`Multitasking`

여러 작업이 동시에 실행되는거. (엄밀히 말하면, cpu에서는 매순간에 하나의 작업만 실행되는데, 짧은 시간간격으로 분할해서 할당하기 때문에 그렇게 느낌)

`Multiprogramming`

메모리 측면을 강조해서 메모리에 동시에 여러프로그램이 올라가는 방식(멀티태스킹도 메모리에 동시에 올라감. 다만 멀티 프로그래밍은 **메모리측면을 강조**해서 사용하는 말)

`Time Sharing`

 `CPU`의 작업시간을 여러 프로그램들이 조금씩 나누어 쓰는 시스템

**CPU를 강조하는 측면**.

`Multiprocess`

여러개 프로세스가 동시에 돌아가는것(사실 다 비슷)

`**Multiprocessor**`

다중 처리기(cpu가 여러개 있는것). 위 4개와는 달리, 1개의 cpu를 나눠쓰는게 아니라, cpu별로 나눠서 작업 실행가능. **더욱 복잡한 메커니즘이 필요하므로** 이 수업에서는 거의 다루지 않음.

## 운영체제의 예

1) MS 윈도우 계열

- MS-DOS와 윈도우3.1 등을 발전시켜 만든, `개인용 컴퓨터(PC)`를 위한 운영체제
    - 윈도우3.1까지는 그 자체로 독립적인 운영체제가 아니라 **MS-DOS 위에서 수행되는 프로그램**이었다. 따라서 컴퓨터 시스템을 완전히 제어할 수 없다는 점과 DOS를 함께 사용해야 한다는 문제점이 있었다.
    - 하나의 온전한 운영체제인 **윈도우 95**가 나오고, 그 이후 윈도우 98을 거쳐 XP, Vista, 윈도우 7, 윈도우 10에 이르게 되었다.
    - **윈도우 NT** : 안정성이 높고 웹서버 등 `다중 사용자용 운영체제`로 사용됨. 웹서버, 전자우편, 파일서버, DB 등으로 사용
- 그래픽 인터페이스와 마우스의 기능을 지원
    - `아이콘 방식` 지원
- 다중 작업(multi tasking) 지원
- `플러그 앤 플레이(plug and play)` 지원

    : 시스템에 새로운 하드웨어를 장착하면 **운영체제가 자동으로 하드웨어를 감지하여 그에 맞게 설정**된다.

- 자체적으로 네트워크 프로그램을 지원

    : 윈도우 사용자들끼리 파일을 공유하거나 프린터 등의 하드웨어를 공유할 수 있는 기능을 갖고 있다.

2) 유닉스 계열

- 1969년 벨 연구소에서 개발
    - **프로그램 개발 환경을 위해 설계된 운영체제**
- 이식성(portability)이 좋고, 커널의 크기가 작으며, 소스 코드가 공개되었다.
    - 이식성 : 소프트웨어를 다른 기종의 기계로 옮기는 것이 얼마나 용이한가를 나타내는 지표
    - 당시의 운영체제는 `어셈블리 언어`로 작성되는 것이 일반적이었으나 유닉스는 대부분 `C언어`로 작성되었다. C언어는 기계어와 독립적인 언어이기 때문에 기계어집합이 다른 컴퓨터에서 다시 컴파일하면 된다. 그리고 고급 언어로 작성되었기 때문에 소스 코드를 이해하기 쉽고, 따라서 다른 기종에 이식하는 것이 훨씬 쉬웠다.
- 하드웨어 기술이나 소프트웨어 기술이 발전하더라도 **`확장성`을 지원할 수 있게 설계되어** 현재까지 널리 사용되고 있다.
- **안정성**이 가장 큰 장점
- `리눅스(Linux)` : 개인용 컴퓨터에서 유닉스를 사용할 수 있게 만든 버전

## 운영체제의 구조

### cpu 스케쥴링

cpu가 너무 빠르기 때문에 그런 CPU를 어떻게 관리해야 하는가를 중점으로 다룬다.

### 메모리 관리

메모리 관리의 **목표**는 메모리 공간과 할당 속도의 효율성을 높이면서, 서로 다른 프로세스의 영역을 침범하지 않도록 보안을 유지하는 것이다.

1. 너무 많은 프로그램을 메모리에 동시에 올리기 보다는, 적어도 CPU에서 원활하게 실행하기 위해 필요한 메모리 용량만큼 할당받을 정도로 지원해주는 것이 좋다. (working set model)
2. 메모리 크기가 한정되어 있으므로, 디스크에서 새로 할당하여 꽉 찼을 때 어떤 것을 쫓아내야 하는가 정해야 한다. (어떤 데이터가 자주 사용될지 미래 예측 => 과거 동향을 보고 결정)

### 메모리 기법

`고정분할 방식`

- 각 분할에는 하나의 프로그램이 적재될 수 있다.
- 메모리에 동시 적재되는 최대 프로그램의 개수가 분할의 개수로 한정됨(비효율적)
- `분할 크기보다 큰 프로그램은 적재 불가능`
- 분할 크기보다 작은 프로그램이 적재되는 경우 남는 영역 **`내부조각(internal fragmentation)`** 발생

내부조각(internal fragmentation)
물리적 메모리를 몇개의 분할로 미리 나누어 관리. 분할 내에 남는영역을 `내부조각(internal fragmentation)` 이라 부름

`가변분할 방식`

매 시점 프로그램의 크기에 맞게 메모리를 분할해서 사용하는 방식. 

- `여전히 물리적 메모리의 크기보다 더 큰 프로그램의 실행은 불가능하다.` (비효율적)

**외부조각(external fragmentation)**
프로그램에 할당되지는 않았지만 그 크기가 작아 프로그램을 올리지 못하는 메모리 영역.

`가상메모리 방식`

물리적 메모리보다 더 큰 프로그램이 실행되는것을 지원한다. 자세한 사항은 chapter2를 참조.

- 현대의 범용 컴퓨터 환경에서 가장 널리 사용되는 기법
- 모든 프로그램은 물리적 메모리와는 독립적으로 **0번지부터 시작하는 자신만의 가상메모리 주소**를 갖는다. 운영체제는 이 가상메모리의 주소를 물리적 메모리의 주소로 **매핑(mapping)**하여 물리적 메모리에 올리게 된다.
- 실행될 수 있는 프로그램의 크기는 가상메모리의 크기에 의해 결정된다.
- 프로그램의 전체 부분이 항상 동시에 사용되는 것은 아니기 때문에 가능함

    => 현재 사용되고 있는 부분만 메모리에 올리고, 나머지는 하드디스크와 같은 보조기억장치에 저장해두었다가 필요할 때 적재하는 방식

    => 스왑 영역(swap area) : 이 때 사용되는 보조기억장치의 영역

### 파일 관리

디스크 스케쥴링. 디스크는 헤드가 움직이면서 처리해야되기 때문에, 어떻게하면 움직임을 최소화하면서 빨리 처리하는가

1. 파일을 연속적으로 저장하는 것이 좋은지, 조각조각 관리하는 것이 좋은지
2. 디스크의 특성에 맞게 파일을 관리

CPU 스케줄링 vs 디스크 스케줄링

CPU는 너무 빠르기 때문에 그런 CPU를 어떻게 관리해야 하는가를 중점으로 다루고,
디스크는 헤드가 움직이면서 처리해야 하므로, 헤드의 움직임을 최소화 해서 빠르게 처리하는 것을 중점으로 다룬다. (엘리베이터 버튼 누르기와 비슷함)

### 입출력 관리

너무 느려서. interrupt 기반

컴퓨터 내부인 CPU, 메모리와 속도차이가 매우 크기 때문에 어떻게 통신할 것인지가 주요 이슈다.

=> **인터럽트**

### 인터럽트

주변장치 및 입출력 장치는 CPU나 메모리와 달리 `인터럽트(interrupt)`라는 메커니즘을 통해 관리가 이루어진다. 주변장치들은 CPU의 서비스가 필요한 경우에 신호를 발생시켜 서비스를 요청하는데, 이 때 발생시키는 신호를 인터럽트라고 한다.

- CPU는 평소에 `CPU 스케줄링`에 따라 작업을 수행하다가, 인터럽트가 발생하면 먼저 **수행 중이던 작업의 상태를 저장**해둔다.
- **인터럽트 처리루틴** - 인터럽트가 발생했을 때 해주어야 할 작업을 정의한 프로그램 코드. **`커널` 내에 존재한다.**

`주변장치`들은 각 장치마다 그 장치에서 일어나는 업무를 관리하기 위한 작은 CPU를 가지고 있다. 이것을 **컨트롤러(controller)**라고 부른다. 컨트롤러는 해당 장치에 대한 업무를 처리하고, 메인 CPU에 인터럽트를 발생시켜 보고한다.

### 프로세스 관리

- 프로세스의 생성과 삭제
- 자원 할당 및 반환
- 프로세스 간 협력

### 그외

- 보호 시스템
- 네트워킹
- 명령어 해석기(command line interpreter)
