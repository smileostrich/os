# 2. System Structure & Program Execution

Complete: No
Date: 2021년 01월 04일

# 2. System Structure & Program Execution

### 컴퓨터 시스템 구조

input - i/o device의 데이터가 컴퓨터 안으로 들어가는것

output - 그 결과를 i/o device 로 전달하는것

메모리는 cpu의 작업 공간

cpu에서 뭔가 일을 하려면, 기계어(인스트럭션)을 실행하는데.

정확하게는 매 clock cycle마다 메모리에서 인스트럭션(기계어)를 하나씩 읽어서 실행함.

i/o device들은 별개의 장치들.

disk 는 I/O 를 모두 수행하는 장치.

`device driver`

소프트웨어.
OS 코드 중 각 장치별 처리 루틴.
운영체제에 있는 코드 중에서, 각 device를 처리하기 위해서 device 인터페이스가 있는데 거기에 맞게 접근할 수 있게해주는 소프트웨어 모듈.

`device controller`

하드웨어.
각각의 I/O device들은 그 device를 전담하는 작은 cpu같은 것들이 붙어있음.(=device controller)
disk에서 헤드가 어떻게 움직이고, 어떤데이터를 읽을지, 
disk의 내부데이터를 통제하는 것은 cpu의 역할이 아니고, disck controller가 통제함.

- 해당 I/O 장치 유형을 관리하는 일종의 작은 CPU.
- 제어 정보를 위해 control register, status register를 가짐
- local buffer를 가짐

`local buffer`

main cpu의 작업공간인 main memory가 있듯이, device controller도 그들의 작업공간을 local buffer라 부름

`cpu의 운명`

매 clock마다 메모리에서 인스트럭션을 하나씩 읽어서 실행하고, 그러고나면 그 다음 인스트럭션을 읽어서 실행.

`레지스터`

`mode bit`

지금 이 cpu에서 실행되는것이 운영체제인지, 사용자 프로그램인지 구분해주는것.

`1 사용자 모드` : 사용자 프로그램 실행
`0 모니터(커널) 모드` : OS 코드 수행

사용자 프로그램이 cpu 제어권을 가지고 있을때는, 제한된 instruction만 cpu에서 실행을 할 수 있음(보안상 목적)(IO 접근 등). 즉, mode bit이 0일때는 모든 instruction 실행가능. 1일때는 제한된 instruction만 실행가능.

`interrupt line`

cpu는 항상 메모리에 있는 instruction만 실행. (I/O device 접근이 필요할땐 controller와 연동)
그때 키보드에서 입력이 들어왔다던가, disk에서 요청이 왔을때 요청을 전달하기위해 존재.

`timer`

하드웨어. 역할은 특정 프로그램이 cpu를 독점하는것을 막는것. (매 클럭 틱 때마다 1씩 감소. 0이되면 타이머 인터럽트 발생. 현재 시간을 계산하기 위해서도 사용.)

컴퓨터를 키면 처음에는 운영체제가 cpu를 가지고 있다가, 사용자 프로그램이 실행되면 그 프로그램에 cpu를 넘겨줌. 단, 그냥 넘겨주는것이 아니라 timer에 값을 세팅 한 다음 프로그램에게 cpu를 넘겨줌. 덕분에 할당된 시간(1초보다 훨씬 짧음)이 지나면 타이머가 cpu에게 interrupt. 이후, cpu는 매번 인스트럭션을 실행하다가 인스트럭션이 끝나고나면 인터럽트 라인을 체크함. 인터럽트 받으면 os에게 cpu 제어권을 줌.(즉, os도 사용자프로그램으로부터 제어권을 못뺏음. 때문에 하드웨어인 timer를 둔 것)
운영체제는 이후 타이머에 값을 세팅 후 다음 프로그램에 cpu 제어권을 줌.

### 입출력의 수행

사용자 프로그램은 본인이 직접 I/O 접근 못함. 즉, OS를 통해야함(cpu 제어권 반납). 이후 OS가 IO controller에게 명령함. IO controller가 local buffer에 원하는 데이터가 들어온걸 확인하면 컨트롤러는 다시 cpu에게 인터럽트를 검. 인터럽트가 들어오면 cpu제어권은 또다시 OS에게 감. OS는 왜 interrupt가 들어온건지 확인. local buffer 값을 요청한 프로그램에 카피해줌. 이후 인터럽트 당한 프로그램에게 cpu 제어권을 돌려줌. timer를 체크해서 시간이 남아 있으면 계속 작업함. 이후 round robin.

사용자 프로그램은 어떻게 I/O를 하는가?

- 시스템콜(trap을 사용하여 인터럽트 벡터의 특정 위치로 이동)
- 제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동
- device controller가 올바른 IO요청인지 확인 후 IO 수행
- IO 완료 시 제어권을 시스템콜 다음 명령으로 옮김(=하드웨어 인터럽트)

시스템콜
사용자 프로그램은 운영체제에게 IO 요청(운영체제의 커널 함수 호출)
단, mode bit이 0이 아니기때문에 사용자 프로그램이 직접 커널 함수 호출하는것이 아닌, 프로그램이 직접 interrupt line을 세팅하는 그런 instruction을 실행.(이것을 trap이라고 부름 = 소프트웨어 인터럽트)

`Interrupt`

- `interrupt(하드웨어 인터럽트)`

    하드웨어가 발생시킨 인터럽트

- `Trap(소프트웨어 인터럽트)`
    - Exception : 프로그램이 오류를 범한 경우.
    - System call : 프로그램이 커널 함수를 호출하는 경우.
- `인터럽트 벡터`

    해당 인터럽트의 처리 루틴 주소를 가지고 있음.
    인터럽트는 종류가 많은데(예를들면 키보드, timer 등) 종류에 따라 해줘야 할 일이 다름.
    즉, 인터럽트 종류마다 인터럽트가 생겼을때, 어디있는 함수를 실행해야하는지 함수의 주소들을 정리해놓은 테이블을 인터럽트 벡터라고 부름.

- `인터럽트 처리 루틴`

    해당 인터럽트를 처리하는 커널 함수

`memory controller`

CPU, DMA가 동시에 특정 메모리 영역에 접근하려고 하면 조율.

`DMA(Direct Memory Access)controller`

원래는 메모리에 접근할 수 있는 장치는 CPU 밖에 없었는데, DMA controller를 두게 되면 dma도 메모리에 접근 가능.
중간중간 IO 작업이 들어왔을때, cpu 인터럽트를 걸어서 메모리에 내용을 카피하게 하는게 오버헤드가 너무 큼.
그래서 cpu는 자기일을 계속 하고 있고, 로컬버퍼에 들어오는 내용이 작업이 끝났으면, DMA가 직접 로컬버퍼의 내용을 메모리에 복사하는일까지 해줌. 복사까지 다 끝나면, 그제서야 CPU에게 인터럽트를 검. 

2장(나중에 이 줄 지움)

`인스트럭션`

기계어(0과 1의 조합). 보통 4바이트. 

`프로그램 카운터 레지스터`

cpu는 매순간 메모리의 어떤 위치에 있는 인스트럭션을 읽어와서 실행을 함.
여기서 메모리 어디에 있는 기계어를 읽는가? 그게 바로 프로그램 카운터 레지스터.
이후 다음 인스트럭션 주소를 가리키기 위해 
1. 4를 증가시킴(워드)
2. 제어구조(if, goto 등), 함수호출 때는 다른 메모리 메모리 주소로 점프함.